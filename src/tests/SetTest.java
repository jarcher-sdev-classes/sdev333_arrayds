package tests;

import adts.ISet;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import structure.SetAL;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests an implementation of the ISet interface.
 *
 * DO NOT EDIT THIS FILE!
 *
 * @author Josh Archer
 * @version 1.0
 */
public class SetTest {
    private ISet set;

    //test arrays
    private Integer[] noDupsArray = {5, 8, 7, 4, 3, 6};
    private Integer[] dupsArray = {3, 5, 5, 6, 3, 6};
    private int[] missing = {1, 2, 9, 10};

    /*
        This method should create and return a new set
        for the methods below.
     */
    private ISet createSet() {
        //instantiate your class here!
        return null;
    }

    /**
     * Creates a new set before each test.
     */
    @BeforeEach
    public void setup() {
        set = createSet();
    }

    /**
     * Tests whether elements can be added to
     * the set successfully.
     */
    @Test
    public void addingElementsTest() {
        addNoDupsElements();

        for (Integer integer : noDupsArray) {
            assertTrue(set.contains(integer), "Elements added to set not discoverable with contains()");
        }
    }

    /**
     * Tests whether duplicate elements are rejected after
     * calling add().
     */
    @Test
    public void duplicateElementsTest() {
        int dupsCount = 0;
        for (Integer integer : dupsArray) {
            try {
                set.add(integer);
            } catch (IllegalArgumentException ex) {
                dupsCount++;
            }
        }

        //three dups should be found
        assertEquals(3, dupsCount, "All three duplicate elements were not rejected");

        //there are three unique elements in the input array
        assertEquals(3, set.size(), "There should be three unique elements in the set after rejected duplicates");
    }

    /**
     * Verifies that the element count in the set is correct
     * after calling addAll().
     */
    @Test
    public void addAllTest() {
        set.addAll(noDupsArray);
        assertEquals(noDupsArray.length, set.size(),
                "There should be " + noDupsArray.length + " unique elements in the set after calling addAll()");
    }

    /**
     * Verifies that duplicates are caught between
     * input parameters and elements already in the set.
     */
    @Test
    public void addAllDuplicateElementsTest() {
        addNoDupsElements();
        assertThrows(IllegalArgumentException.class, () -> set.addAll(noDupsArray));
    }

    /**
     * Verifies that duplicate parameters result in
     * an exception.
     */
    @Test
    public void addAllDuplicateParametersTest() {
        assertThrows(IllegalArgumentException.class, () -> set.addAll(dupsArray));
    }

    /**
     * Verifies that the set reports the size of the structure
     * correctly.
     */
    @Test
    public void sizeTest() {
        addNoDupsElements();

        //list should be empty to start with
        assertEquals(set.size(), noDupsArray.length,
                "List should have size " + noDupsArray.length + "after calls to add()");
        assertFalse(set.isEmpty(), "List should not be empty after calling add()");
    }

    /**
     * Verifies that the set reports the size of the structure
     * correctly.
     */
    @Test
    public void sizeEmptyTest() {
        //list should be empty to start with
        assertEquals(0, set.size(), "List should have size 0 after no calls to add()");
        assertTrue(set.isEmpty(), "List should be empty after no calls to add()");
    }

    /**
     * Verifies that the capacity does not change unless exceeded.
     */
    @Test
    public void capacityTest() {
        addNoDupsElements();

        //capacity should be the same after a few (< 10) elements are added
        assertEquals(10, set.capacity(), "Capacity should be 10 unless 11 or more elements have been added");
    }

    /**
     * Verifies that the capacity of an empty set defaults to 10.
     */
    @Test
    public void capacityEmptyTest() {
        assertEquals(10, set.capacity(), "Capacity should default to 10 for a new set");
    }

    /**
     * Verifies that the internal capacity of the set is doubling as necessary.
     */
    @Test
    public void resizeCapacityTest() {
        int[] boundaries = new int[8]; //{10, 20, 40, 80, 160, 320, 640, 1280};
        int max = 10;
        for (int i = 0; i < boundaries.length; i++) {
            boundaries[i] = max;
            max *= 2;
        }

        int boundaryIndex = 0;
        for (int i = 1; i <= boundaries[boundaries.length - 2] + 1; i++) {
            set.add(i);

            if (i == boundaries[boundaryIndex] + 1) {
                boundaryIndex++;
            }

            int expectedCap = boundaries[boundaryIndex];
            assertEquals(expectedCap, set.capacity(),
                "Capacity should be " + expectedCap + " unless " + (expectedCap + 1) +
                " or more elements have been added");
        }
    }

    /**
     * Verifies that elements can be found in the set
     * with contains().
     */
    @Test
    public void containsExistsTest() {
        addNoDupsElements();

        //make sure elements are discoverable
        for (Integer integer : noDupsArray) {
            assertTrue(set.contains(integer), "Added element not discoverable by contains()");
        }
    }

    /**
     * Verifies that elements not in the set cannot be discovered
     * with contains().
     */
    @Test
    public void containsMissingTest() {
        addNoDupsElements();

        //make sure elements are discoverable
        for (int elem : missing) {
            assertFalse(set.contains(elem), "Missing element is discoverable by contains()");
        }
    }

    /**
     * Verifies that contains() does not return true
     * when the set is empty.
     */
    @Test
    public void containsOnEmptyListTest() {
        //contains should always return false on empty set
        assertFalse(set.contains(3), "Missing element is discoverable by contains()");

        //add an element and confirm contains() can discover it
        set.add(3);
        assertTrue(set.contains(3), "Element added to set is not discoverable by contains()");
    }

    /**
     * Verifies that various elements added to a set can each be found and
     * removed.
     * @param toRemove the element to search for
     */
    @ParameterizedTest
    @ValueSource(ints = {5, 8, 7, 4, 3, 6})
    public void removeIndividual(int toRemove) {
        addNoDupsElements();
        assertEquals(noDupsArray.length, set.size(), "List size should be " +
                noDupsArray.length + " before removing all elements");

        set.remove(toRemove);
        assertEquals(noDupsArray.length - 1, set.size(),
            "List size should be one smaller after removing all elements");
        assertFalse(set.contains(toRemove), "Element can be found after being removed");
    }

    /**
     * Verifies that various missing elements cannot be removed from the set.
     *
     * @param toFind the element to search for in the set
     */
    @ParameterizedTest
    @ValueSource(ints = {2, 9, -2, 0, 11})
    public void removeMissingTest(int toFind) {
        addNoDupsElements();

        assertThrows(NoSuchElementException.class, () -> set.remove(toFind),
                "No exception is thrown when removing a missing element");
    }

    /**
     * Verifies that the correct exception is thrown when removing from an empty set.
     */
    @Test
    public void removeOnEmptySetTest() {
        //no elements are present, this should give an exception
        assertThrows(NoSuchElementException.class, () -> set.remove(2),
                "Exception should be thrown on an empty set");
    }

    /**
     * Verifies that clear() works correctly on an empty
     * set.
     */
    @Test
    public void clearEmptyTest() {
        //make sure no errors are encountered
        set.clear();

        assertEquals(0, set.size(), "Set size should be 0 after calling clear()");
        assertTrue(set.isEmpty(), "Set should be empty after calling clear");
    }

    /**
     * Verifies that clear() works correctly on a non-empty
     * set.
     */
    @Test
    public void clearNotEmptyTest() {
        addNoDupsElements();

        //make sure no errors are encountered
        set.clear();

        assertEquals(0, set.size(), "Set size should be 0 after calling clear()");
        assertTrue(set.isEmpty(), "Set should be empty after calling clear");
    }

    /**
     * Tests whether two different objects, which are considered
     * equivalent according to the equals() method are disallowed from
     * both being in the set.
     */
    @Test
    public void duplicateEquivalentTest() {
        //these two objects are different, but equivalent according to equals()
        TestClass first = new TestClass(1, "Hello");
        TestClass second = new TestClass(1, "World");

        set.add(first);
        assertThrows(IllegalArgumentException.class, () -> set.add(second));
    }

    /**
     * Tests whether two different objects, which are considered
     * equivalent according to the equals() method, can be found
     * using either object after the other is inserted in the set.
     */
    @Test
    public void duplicateContainsTest() {
        //these two objects are different, but equivalent according to equals()
        TestClass first = new TestClass(1, "Hello");
        TestClass second = new TestClass(1, "World");

        set.add(first);
        assertTrue(set.contains(second));
    }

    /**
     * Tests whether two different objects, which are considered
     * equivalent according to the equals() method, can be found
     * and removed after the other is inserted in the set.
     */
    @Test
    public void duplicateRemoveTest() {
        //these two objects are different, but equivalent according to equals()
        TestClass first = new TestClass(1, "Hello");
        TestClass second = new TestClass(1, "World");

        set.add(first);
        assertEquals(1, set.size(), "set size() should return 1 after an elements is added.");
        assertDoesNotThrow(() -> set.remove(second)); //should not throw an exception
    }

    /**
     * Tests that a large number of elements can be added to the set and it
     * behaves predictably. This test is repeated 10 times with different
     * numbers of elements added to the set, as well as different amount
     * of duplicates.
     */
    @RepeatedTest(10)
    public void largeSetTest() {
        Random random = new Random();
        int randomSetSize = Math.max(5, random.nextInt(1000));

        //the higher this number, the more duplicates will be created
        int duplicateChance = random.nextInt(5) + 1;
        int successfulAdds = 0;

        //add enough elements for force a resize
        ArrayList<Integer> added = new ArrayList<>();
        for (int i = 1; i <= randomSetSize; i++) {
            int element = randomSetSize / duplicateChance;
            added.add(element);

            try {
                set.add(element);
                successfulAdds++;
            }
            catch (IllegalArgumentException ex) {
                assert true; //do nothing...
            }
        }

        //make sure elements are discoverable
        for (Integer integer : added) {
            assertTrue(set.contains(integer), "Element is not discoverable by contains()");
        }

        //number of elements should not be zero
        assertEquals(successfulAdds, set.size(),
                "Set size should be " + successfulAdds + " after calling add()");
        assertFalse(set.isEmpty(), "Set should not be empty after calling add()");
    }

    /**
     * Verifies that add() works correctly after adding
     * elements, removing all elements, then inserting
     * a new element.
     */
    @Test
    public void addAfterEmptyingSetTest() {
        addNoDupsElements();

        //remove all elements
        for (Integer integer : noDupsArray) {
            set.remove(integer);
        }

        //adding should still be successful
        set.add(2);
        assertEquals(1, set.size(), "The size of your set should be 1 after calling add() on an empty set");
    }

    /**
     * Verifies that the removeAll() method can find and remove
     * elements found in the set.
     */
    @Test
    public void removeAllTest() {
        addNoDupsElements();
        int[] toRemove = {7, 4, 3};

        assertEquals(noDupsArray.length, set.size(), "Set size incorrect after adding elements");
        for (int removed : toRemove) {
            assertTrue(set.contains(removed), "Element inserted with add() cannot be found");
        }

        set.removeAll(7, 4, 3);

        assertEquals(noDupsArray.length - 3, set.size(), "Set size incorrect after adding elements");
        for (int removed : toRemove) {
            assertFalse(set.contains(removed), "Element removed by removeAll() can still be found");
        }
    }

    /**
     * Verifies that removeAll() throws the expected exception when
     * passed missing elements.
     */
    @Test
    public void removeAllMissingTest() {
        addNoDupsElements();

        //all missing
        assertThrows(NoSuchElementException.class, () -> set.removeAll(1, 2, 9, 10));

        //partial missing
        assertThrows(NoSuchElementException.class, () -> set.removeAll(7, 3, 9, 10));
    }

    /*
     * Adds a group of elements to the set, without any duplicates being added.
     */
    private void addNoDupsElements() {
        for (Integer integer : noDupsArray) {
            set.add(integer);
        }
        assertEquals(noDupsArray.length, set.size(),
                "The size of your set should be " + noDupsArray.length + "after calling add()");
    }

    private static class TestClass {
        private int identifier;
        private String value;

        public TestClass(int identifier, String value) {
            this.identifier = identifier;
            this.value = value;
        }

        @Override
        public boolean equals(Object other) {
            if (this == other) {
                return true;
            }

            if (other == null || getClass() != other.getClass()) {
                return false;
            }

            TestClass testClass = (TestClass) other;
            return identifier == testClass.identifier;
        }

        @Override
        public int hashCode() {
            return identifier;
        }

        @Override
        public String toString() {
            return "TestClass{" +
                    "identifier=" + identifier +
                    ", value=" + value +
                    '}';
        }
    }
}
